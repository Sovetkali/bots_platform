# Создание нового бота в Hope Platform

## Оглавление
1. [Обзор архитектуры](#обзор-архитектуры)
2. [Создание нового бота: пошаговая инструкция](#создание-нового-бота-пошаговая-инструкция)
3. [Диаграммы взаимодействия](#диаграммы-взаимодействия)
4. [Возможные проблемы и их решения](#возможные-проблемы-и-их-решения)
5. [Лучшие практики](#лучшие-практики)

---

## Обзор архитектуры

Hope Platform построена по модульной архитектуре с четким разделением ответственности между компонентами:

### Ключевые компоненты

#### 1. **BotRegistry** ([`core/registry.py`](core/registry.py:1))
- **Назначение**: Центральный реестр для регистрации и управления всеми ботами
- **Функции**:
  - Регистрация фабрик ботов
  - Инициализация всех ботов
  - Параллельный запуск/остановка
  - Обработка ошибок

#### 2. **BotClient** ([`core/base/client.py`](core/base/client.py:1))
- **Назначение**: Абстрактный базовый класс для клиентов ботов
- **Обязательные методы**: `start()`, `stop()`
- **Реализация**: [`AiogramBotClient`](core/clients/aiogram_client.py:7)

#### 3. **BotRouter** ([`core/base/router.py`](core/base/router.py:1))
- **Назначение**: Абстрактный класс для маршрутизаторов команд
- **Свойство**: `router` - возвращает aiogram.Router

#### 4. **BotService** ([`core/base/service.py`](core/base/service.py:1))
- **Назначение**: Бизнес-логика бота

### Архитектурный паттерн
Платформа использует паттерн **Factory + Simple Container + Registry**:
- **Factory**: Создает экземпляры ботов через фабричные функции
- **Simple Container**: Упрощенный контейнер для создания компонентов бота
- **Registry**: Централизованное управление ботами через реестр

#### 5. **BotContainer** ([`core/bot_container.py`](core/bot_container.py:1))
- **Назначение**: Упрощенный контейнер для создания компонентов бота
- **Функции**:
  - Регистрация конфигураций ботов
  - Создание компонентов бота (сервис → роутер → клиент)
  - Кэширование созданных экземпляров
  - Простое управление зависимостями

---

## Создание нового бота: пошаговая инструкция

### Шаг 1: Создание структуры папки бота

Создайте новую папку в директории `bots/`:

```
bots/
└── ваш_бот/
    ├── __init__.py      # Регистрация бота
    ├── client.py        # Клиент бота
    ├── router.py        # Маршрутизатор команд
    └── service.py       # Бизнес-логика
```

### Шаг 2: Настройка конфигурации

Добавьте переменную окружения в [`utils/config.py`](utils/config.py:5):

```python
class Config(BaseSettings):
    # ... существующие настройки
    ВАШ_БОТ_TOKEN: SecretStr  # Добавьте эту строку
```

И в файл `.env`:
```
ВАШ_БОТ_TOKEN=your_bot_token_here
```

### Шаг 3: Создание Service (бизнес-логика)

[`bots/ваш_бот/service.py`](bots/ваш_бот/service.py:1):
```python
from core.base.service import BotService

class ВашБотService(BotService):
    async def start_command(self):
        return "Добро пожаловать в ВашБот!"

    async def handle_message(self, text: str):
        # Ваша бизнес-логика
        return f"Вы сказали: {text}"
```

### Шаг 4: Создание Router (маршрутизатор)

[`bots/ваш_бот/router.py`](bots/ваш_бот/router.py:1):
```python
from aiogram import Router
from aiogram.types import Message
from aiogram.filters import Command, Text
from core.base.router import BotRouter
from .service import ВашБотService

class ВашБотRouter(BotRouter):
    def __init__(self, service: ВашБотService):
        self._router = Router()
        self._service = service
        self._register_handlers()

    def _register_handlers(self):
        # Регистрация команды /start
        self._router.message.register(self.start, Command("start"))

        # Регистрация обработки текстовых сообщений
        self._router.message.register(self.handle_message, Text())

    @property
    def router(self) -> Router:
        return self._router

    async def start(self, message: Message):
        text = await self._service.start_command()
        await message.answer(text)

    async def handle_message(self, message: Message):
        text = await self._service.handle_message(message.text)
        await message.answer(text)
```

### Шаг 5: Создание Client (клиент)

[`bots/ваш_бот/client.py`](bots/ваш_бот/client.py:1):
```python
from core.clients.aiogram_client import AiogramBotClient
from core.models.client_config import BotClientConfig
from core.models.bot_mode import BotMode
from aiogram import Router
from utils.config import config

class ВашБотClient(AiogramBotClient):
    name = "ваш_бот"  # Уникальное имя бота

    def __init__(self, router: Router):
        super().__init__(
            name=self.name,
            config=BotClientConfig(
                token=config.ВАШ_БОТ_TOKEN.get_secret_value(),
                mode=BotMode.POLLING,  # или BotMode.WEBHOOK
                webhook_url=None
            )
        )
        self.dp.include_router(router)
```

### Шаг 6: Конфигурация бота

Добавьте конфигурацию бота в [`utils/bots_config.py`](utils/bots_config.py:1):
```python
from bots.ваш_бот.service import ВашБотService
from bots.ваш_бот.router import ВашБотRouter
from bots.ваш_бот.client import ВашБотClient

BOT_CONFIGS = {
    'ваш_бот': {
        'name': 'ваш_бот',
        'service_class': ВашБотService,
        'router_class': ВашБотRouter,
        'client_class': ВашБотClient,
        'dependencies': {}  # Дополнительные зависимости
    }
}
```

### Шаг 7: Регистрация бота

[`bots/ваш_бот/__init__.py`](bots/ваш_бот/__init__.py:1):
```python
from core.registry import register_bot
from core.bot_container import container
from utils.bots_config import BOT_CONFIGS

# Регистрируем конфигурацию в DI контейнере
container.register_bot(BOT_CONFIGS['ваш_бот']['name'], BOT_CONFIGS['ваш_бот'])

def create_bot():
    # Контейнер создаёт бота по конфигурации
    return container.get_bot(BOT_CONFIGS['ваш_бот']['name'])

# Регистрация фабрики в системе
register_bot.register(BOT_CONFIGS['ваш_бот']['name'], create_bot)
```

### Шаг 8: Запуск платформы

Запустите основное приложение:
```bash
python main.py
```

Платформа автоматически:
1. Импортирует все модули ботов
2. Регистрирует конфигурации в DI контейнере
3. Создаёт экземпляры ботов через фабрики
4. Запускает всех ботов параллельно

---

## Диаграммы взаимодействия

### Диаграмма последовательности запуска бота

```mermaid
sequenceDiagram
    participant M as main.py
    participant R as BotRegistry
    participant F as Factory Function
    participant CT as BotContainer
    participant C as BotClient
    participant S as BotService
    participant RT as BotRouter

    M->>R: register_bot.init_all()
    R->>F: create_bot()
    F->>CT: container.get_bot()
    CT->>S: Service()
    CT->>RT: Router(service)
    CT->>C: Client(router)
    CT->>CT: Кэширует экземпляр
    CT->>F: Возвращает клиент
    R->>R: Сохраняет экземпляр

    M->>R: register_bot.start_all()
    R->>C: start() для каждого бота
    C->>C: Запуск polling/webhook
```

### Диаграмма обработки сообщения

```mermaid
sequenceDiagram
    participant U as User
    participant C as BotClient
    participant RT as Router
    participant H as Handler
    participant S as Service

    U->>C: Отправляет сообщение
    C->>RT: Передает сообщение
    RT->>H: Вызывает соответствующий хендлер
    H->>S: Вызывает метод сервиса
    S->>H: Возвращает результат
    H->>C: Отправляет ответ
    C->>U: Пользователь получает ответ
```

### Архитектурная диаграмма

```mermaid
graph TB
    subgraph "Bot Module"
        S[Service<br/>Бизнес-логика]
        RT[Router<br/>Маршрутизация]
        C[Client<br/>Клиент бота]
        CFG_BOT[Bot Config<br/>Конфиг бота]
    end

    subgraph "Core Platform"
        REG[BotRegistry<br/>Реестр ботов]
        CT[BotContainer<br/>DI Контейнер]
        BASE[Base Classes<br/>Абстракции]
        CFG[Config<br/>Конфигурация]
    end

    CFG_BOT --> CT
    S --> RT
    RT --> C
    C --> CT
    CT --> REG
    REG --> BASE
    CFG --> C
```

---

## Возможные проблемы и их решения

### Проблема 1: Бот не регистрируется

**Симптомы**: Бот не появляется в логах при запуске

**Причины**:
- Файл `__init__.py` не импортируется
- Ошибка в фабричной функции
- Конфликт имен ботов

**Решение**:
1. Проверьте, что папка бота имеет `__init__.py`
2. Убедитесь, что `register_bot.register()` вызывается
3. Используйте уникальное имя для бота

### Проблема 2: Ошибка аутентификации

**Симптомы**: `401 Unauthorized` или подобные ошибки

**Причины**:
- Неверный токен бота
- Токен не добавлен в `.env`
- Опечатка в имени переменной конфигурации

**Решение**:
1. Проверьте токен в @BotFather
2. Убедитесь, что переменная добавлена в `config.py` и `.env`
3. Проверьте соответствие имен в `config.py` и `client.py`

### Проблема 3: Хендлеры не работают

**Симптомы**: Команды не обрабатываются

**Причины**:
- Роутер не зарегистрирован в клиенте
- Ошибка в регистрации хендлеров
- Конфликт фильтров

**Решение**:
1. Убедитесь, что `self.dp.include_router(router)` вызывается
2. Проверьте правильность регистрации в `_register_handlers()`
3. Используйте разные фильтры для разных хендлеров

### Проблема 4: Ошибки при запуске

**Симптомы**: Исключения при `register_bot.init_all()`

**Причины**:
- Ошибки импорта
- Проблемы с зависимостями
- Неправильная инициализация

**Решение**:
1. Проверьте все импорты в файлах бота
2. Убедитесь, что все зависимости установлены
3. Добавьте обработку исключений в фабричную функцию

### Проблема 5: Бот не отвечает на сообщения

**Симптомы**: Сообщения отправляются, но ответа нет

**Причины**:
- Бот запущен в неправильном режиме
- Проблемы с сетью
- Ошибки в бизнес-логике

**Решение**:
1. Проверьте режим бота (POLLING/WEBHOOK)
2. Убедитесь в стабильности соединения
3. Добавьте логирование для отладки

---

## Лучшие практики

### 1. Организация кода

**✅ Правильно:**
```python
# service.py - чистая бизнес-логика
class MyBotService(BotService):
    async def process_order(self, order_data):
        # Только бизнес-логика
        return await self._validate_and_process(order_data)
```

**❌ Неправильно:**
```python
# Смешивание логики в роутере
async def handle_order(message: Message):
    # Бизнес-логика не должна быть здесь
    if message.text == "order":
        # ... сложная логика обработки
```

### 2. Обработка ошибок

**Рекомендуемый подход:**
```python
async def handle_message(self, message: Message):
    try:
        result = await self._service.process(message.text)
        await message.answer(result)
    except ValidationError as e:
        await message.answer(f"Ошибка валидации: {e}")
    except Exception as e:
        logger.error(f"Unexpected error: {e}")
        await message.answer("Произошла ошибка")
```

### 3. Конфигурация

**Безопасное использование токенов:**
```python
# Правильно - через SecretStr
token=config.BOT_TOKEN.get_secret_value()

# Неправильно - прямое использование
token=config.BOT_TOKEN  # Может логироваться
```

### 4. Логирование

**Добавьте информативное логирование:**
```python
import logging
from utils.logger import logger

class YourBotService(BotService):
    async def process_request(self, data):
        logger.info(f"Processing request: {data}")
        # ... логика
        logger.info("Request processed successfully")
```

### 5. Тестирование

**Создавайте тесты для сервисов:**
```python
# tests/bots/your_bot/test_service.py
import pytest
from bots.your_bot.service import YourBotService

class TestYourBotService:
    async def test_start_command(self):
        service = YourBotService()
        result = await service.start_command()
        assert "Добро пожаловать" in result
```

---

## Заключение

Hope Platform предоставляет мощную и гибкую архитектуру для создания Telegram ботов. Следуя этой инструкции, вы сможете:

1. **Быстро создавать** новых ботов с четким разделением ответственности
2. **Легко поддерживать** код благодаря модульной архитектуре
3. **Масштабировать** приложение добавляя новые модули
4. **Отлаживать** проблемы с помощью встроенного логирования

Для дополнительной информации обращайтесь к исходному коду существующих ботов и документации aiogram.

---
*Документация обновлена: 2026-01-29*
*Обновлена информация об упрощенной архитектуре контейнера*
